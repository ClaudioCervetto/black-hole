<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Buco Nero con Rete e Narrativa</title>
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Share+Tech&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
      font-family: 'Share Tech', sans-serif;
      color: white;
      touch-action: none;
    }
    
    #page-wrapper {
      width: 100%;
      height: 100vh;
      position: relative;
      will-change: transform;
      transition: transform 0.03s ease-out;
    }
    
    /* Transizione per la griglia su smartphone */
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      display: block;
      z-index: 0;
      transition: opacity 1s ease;
    }
    
    canvas.canvas-hidden {
      opacity: 0 !important;
    }
    
    .star {
      position: absolute;
      width: 1px;
      height: 1px;
      background-color: white;
      border-radius: 50%;
      z-index: 1;
      opacity: 0;
      transition: opacity 1s ease, transform 1s ease, background-color 1s ease;
    }
    
    #black-hole, #black-hole-aura {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
    }
    
    #black-hole {
      width: 40px;
      height: 40px;
      background-color: black;
      border: 2px solid white;
      z-index: 3;
      transform-origin: center;
      transition: opacity 3s ease, background-color 1s ease, border-color 1s ease;
    }
    
    #black-hole-aura {
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 80%);
      z-index: 2;
      animation: pulse 2s infinite alternate;
      transition: opacity 3s ease, background 1.5s ease;
    }
    
    @keyframes pulse {
      0% { transform: translate(-50%, -50%) scale(1); opacity: 0.2; }
      100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.05; }
    }
    
    #title {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(20px, 5vw, 32px);
      letter-spacing: -1px;
      text-transform: uppercase;
      text-align: center;
      z-index: 10;
      opacity: 0;
      animation: fadeInOut 6s ease-in-out forwards;
      width: 90%;
    }
    @keyframes fadeInOut {
      0% { opacity: 0; }
      15% { opacity: 1; }
      75% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    .sequence-text {
      position: absolute;
      padding: 15px;
      width: 85vw; 
      max-width: 450px; 
      font-family: 'Share Tech Mono', monospace;
      color: white;
      opacity: 0;
      transition: opacity 0.5s ease, color 0.5s ease, text-shadow 0.5s ease, top 0.5s ease, left 0.5s ease, transform 0.5s ease;
      z-index: 10;
      text-shadow: 0 0 15px rgba(0, 0, 0, 1), 0 0 5px rgba(0, 0, 255, 0.8);
      pointer-events: none;
      line-height: 1.5;
      
      bottom: 5%;
      left: 5%;
      text-align: left; /* Sempre allineato a sinistra a bandiera */
    }
    
    .sequence-text.pos-inside {
      bottom: auto;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: left; /* Anche quando è al centro, il testo è a bandiera a sinistra */
    }
    
    #video-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.01);
      width: 100%;
      height: 100%;
      z-index: 5;
      opacity: 0;
      transition: opacity 1s ease;
      overflow: hidden;
      pointer-events: none;
    }
    
    #video-slider {
      display: flex;
      width: 300%;
      height: 100%;
      position: relative;
      left: 0%;
      transition: left 0.5s ease-out;
    }
    
    .sequence-video {
      width: 33.333%;
      height: 100%;
      object-fit: cover;
      flex-shrink: 0;
    }
    
    #scroll-hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: clamp(12px, 3vw, 14px);
      text-align: center;
      width: 90%;
      opacity: 0;
      animation: fadeInHint 2s ease 4s forwards;
      pointer-events: none;
      z-index: 20;
    }
    @keyframes fadeInHint {
      to { opacity: 0.5; }
    }
  </style>
</head>
<body>
  <div id="page-wrapper">
    <div id="title">Buco nero nelle vicinanze</div>
    <div id="scroll-hint">Scorri o fai swipe per esplorare</div>
    
    <canvas id="grid"></canvas>
    
    <div id="black-hole-aura"></div>
    <div id="black-hole"></div>
    
    <div id="sequence-text-1" class="sequence-text">
      Quando una stella almeno 20 volte più massiccia del Sole finisce il suo combustibile...<br>
      Il suo nucleo collassa sotto il proprio peso.<br>
      Ciò che resta è un oggetto così denso che nemmeno la luce può sfuggirgli:<br>
      <strong>un buco nero stellare.</strong>
    </div>
    
    <div id="sequence-text-2" class="sequence-text">
      Non possiamo vedere un buco nero direttamente.<br>
      Emette zero luce.<br>
      Ma possiamo <strong>vedere ciò che gli succede intorno.</strong><br>
      La luce delle stelle vicine si piega. Materia che cade emette raggi X prima di sparire.
    </div>
    
    <div id="sequence-text-3" class="sequence-text">
      Li troviamo osservando il loro effetto sull'ambiente.<br>
      - Stelle che orbitano nel vuoto.<br>
      - Materia che si scalda mentre cade.<br>
      - Onde gravitazionali.
    </div>
    
    <div id="sequence-text-4" class="sequence-text">
      Ci stiamo avvicinando all'orizzonte degli eventi.<br>
      Qui, il tempo rallenta per chi osserva da fuori.<br>
      La luce viene tirata indietro, come se il tempo si fermasse.
    </div>
    
    <div id="sequence-text-5" class="sequence-text">
      Dal nostro punto di vista, entriamo normalmente.<br>
      Ma oltre l'orizzonte... non si può più tornare indietro.<br>
      Sei <strong>fuori dal nostro universo osservabile.</strong>
    </div>
    
    <div id="sequence-text-6" class="sequence-text">
      La gravità diventa estrema. Se cadi piedi per primi, i tuoi piedi sentiranno una forza molto più grande della testa.<br>
      Il risultato? <strong>Spaghettificazione.</strong><br>
      La materia si allunga, si disintegra, e infine scompare.
    </div>
    
    <div id="sequence-text-7" class="sequence-text">
      Al centro, la teoria dice che c'è una <strong>singolarità</strong><br>
      Un punto con densità infinita. Dove le leggi della fisica si spezzano.<br>
      Forse non è un punto, forse c'è qualcosa che ancora non capiamo.<br>
      Forse... una nuova fisica. Un ponte per altrove?
    </div>
    
    <div id="sequence-text-8" class="sequence-text">
      I buchi neri ci sfidano a comprendere l'universo.<br>
      Ci raccontano di stelle morte, ma anche di nascita di conoscenza.<br>
      Guardare dentro di loro è guardare oltre i limiti della scienza.<br>
      È guardare noi stessi.
    </div>
    
    <div id="video-container">
      <div id="video-slider">
        <video id="collapse-video-1" class="sequence-video" muted autoplay playsinline loop>
           <source src="C:\Users\claud\Desktop\Composizione 1_2.mp4" type="video/mp4">
        </video>
        <video id="collapse-video-2" class="sequence-video" muted autoplay playsinline loop>
           <source src="C:\Users\claud\Desktop\2.mp4" type="video/mp4">
        </video>
        <video id="collapse-video-3" class="sequence-video" muted autoplay playsinline loop>
           <source src="C:\Users\claud\Desktop\3.mp4" type="video/mp4">
        </video>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('grid');
    const ctx = canvas.getContext('2d');
    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    
    let scale = 1;
    let lastScale = 1; 
    let gridHidden = false; // Flag per nascondere la griglia su mobile
    
    const zoomFactor = 1.05; 
    const dampingFactor = 0.5; 
    const maxScale = 150; 
    const centerX = width / 2;
    const centerY = height / 2;
    
    let starSpeedMultiplier = 1;
    let currentPhase = -1;

    const sequenceTexts = [];
    for (let i = 1; i <= 8; i++) {
      sequenceTexts.push(document.getElementById(`sequence-text-${i}`));
    }
    
    // Soglie per Desktop
    const desktopThresholds = [
      { min: 0.9, max: 3.0 },     // T1
      { min: 3.0, max: 6.0 },     // T2
      { min: 6.0, max: 10.0 },    // T3
      { min: 10.0, max: 15.0 },   // T4
      { min: 15.0, max: 22.0 },   // T5
      { min: 22.0, max: 35.0 },   // T6 
      { min: 35.0, max: 50.0 },   // T7 
      { min: 50.0, max: 80.0 }    // T8 
    ];

    // Soglie per Mobile (molto più compresse per finire mentre il cerchio si allarga)
    const mobileThresholds = [
      { min: 0.9, max: 1.5 },     // T1
      { min: 1.5, max: 2.5 },     // T2
      { min: 2.5, max: 4.0 },     // T3
      { min: 4.0, max: 5.5 },     // T4
      { min: 5.5, max: 7.5 },     // T5
      { min: 7.5, max: 10.0 },    // T6
      { min: 10.0, max: 13.0 },   // T7
      { min: 13.0, max: 18.0 }    // T8
    ];
    
    function getActiveThresholds() {
      return window.innerWidth < 600 ? mobileThresholds : desktopThresholds;
    }
    
    const videoContainer = document.getElementById('video-container');
    const videoSlider = document.getElementById('video-slider');
    const collapseVideos = document.querySelectorAll('.sequence-video'); 
    
    const videoAppearThreshold = 85; 
    const videoFullscreenThreshold = 100; 
    const slideThreshold = 110; 
    const slideCompleteThreshold = 140; 
    let videoVisible = false;
    let currentVideoIndex = 0;
    const stars = [];

    const spacing = 50;
    const lines = [];
    let animatingLines = true;
    
    for (let x = 0; x <= width; x += spacing) {
      const startFromTop = Math.random() > 0.5;
      lines.push({ dir: 'v', start: { x: x, y: startFromTop ? 0 : height }, end: { x: x, y: startFromTop ? height : 0 }, delay: Math.random() * 3 });
    }
    for (let y = 0; y <= height; y += spacing) {
      const startFromLeft = Math.random() > 0.5;
      lines.push({ dir: 'h', start: { x: startFromLeft ? 0 : width, y: y }, end: { x: startFromLeft ? width : 0, y: y }, delay: Math.random() * 3 });
    }

    function calculateMeshDeformation(dx, dy, deformFactor) {
      const distance = Math.sqrt(dx * dx + dy * dy);
      return deformFactor * 800 / (distance + 20);
    }

    function drawGrid(deform = 0, time = 0) {
      if(gridHidden) return; // Ottimizzazione se la griglia non è più visibile
      ctx.clearRect(0, 0, width, height);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; 
      ctx.lineWidth = 1.0; 

      for (let line of lines) {
        if (time < line.delay) continue;
        const lineProgress = Math.min(1, (time - line.delay) / 2); 
        if (lineProgress <= 0) continue;
        
        ctx.beginPath();
        if (line.dir === 'v') {
          const startY = line.start.y;
          const endY = line.end.y;
          const currentY = startY + (endY - startY) * lineProgress;
          let lastX = line.start.x;
          let lastY = startY;
          ctx.moveTo(lastX, lastY);
          
          for (let y = startY; y !== currentY; y += (endY > startY ? 5 : -5)) {
            if ((endY > startY && y > currentY) || (endY < startY && y < currentY)) break;
            let dx = line.start.x - centerX;
            let dy = y - centerY;
            let distortion = deform > 0 ? Math.cos(Math.atan2(dy, dx)) * calculateMeshDeformation(dx, dy, deform) : 0;
            ctx.lineTo(line.start.x - distortion, y);
          }
          let dx = line.start.x - centerX;
          let dy = currentY - centerY;
          let distortion = deform > 0 ? Math.cos(Math.atan2(dy, dx)) * calculateMeshDeformation(dx, dy, deform) : 0;
          ctx.lineTo(line.start.x - distortion, currentY);
          
        } else {
          const startX = line.start.x;
          const endX = line.end.x;
          const currentX = startX + (endX - startX) * lineProgress;
          let lastX = startX;
          let lastY = line.start.y;
          ctx.moveTo(lastX, lastY);
          
          for (let x = startX; x !== currentX; x += (endX > startX ? 5 : -5)) {
            if ((endX > startX && x > currentX) || (endX < startX && x < currentX)) break;
            let dx = x - centerX;
            let dy = line.start.y - centerY;
            let distortion = deform > 0 ? Math.sin(Math.atan2(dy, dx)) * calculateMeshDeformation(dx, dy, deform) : 0;
            ctx.lineTo(x, line.start.y - distortion);
          }
          let dx = currentX - centerX;
          let dy = line.start.y - centerY;
          let distortion = deform > 0 ? Math.sin(Math.atan2(dy, dx)) * calculateMeshDeformation(dx, dy, deform) : 0;
          ctx.lineTo(currentX, line.start.y - distortion);
        }
        ctx.stroke();
      }
    }

    function drawRadialGravityLines(timeInSeconds) {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; 
      ctx.lineWidth = 1.0; 
      ctx.beginPath();
      
      const numRays = 300; 
      const maxRadius = Math.max(width, height); 
      const blackHoleRadius = (40 * scale) / 2; 
      
      for (let i = 0; i < numRays; i++) {
        const angle = (i / numRays) * Math.PI * 2;
        const speed = 600 + (i % 5) * 200; 
        const phase = (timeInSeconds * speed + i * 113) % maxRadius;
        let r = maxRadius - phase;
        
        if (r > blackHoleRadius) {
          const length = 15 + (r / maxRadius) * 120 + (i % 4) * 25;
          let endR = Math.max(r - length, blackHoleRadius); 
          
          ctx.moveTo(centerX + Math.cos(angle) * r, centerY + Math.sin(angle) * r);
          ctx.lineTo(centerX + Math.cos(angle) * endR, centerY + Math.sin(angle) * endR);
        }
      }
      ctx.stroke();
    }

    let zoomEnabled = false;

    window.addEventListener('load', () => {
      setTimeout(() => {
        document.getElementById('black-hole').style.opacity = 1;
        document.getElementById('black-hole-aura').style.opacity = 1;
        
        setTimeout(() => {
          zoomEnabled = true;
          applyGlobalWiggleContinuously();
          updateSequenceTexts(scale);
        }, 500);
      }, 3000); 
    });

    function createStars(n) {
      for (let i = 0; i < n; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        const left = Math.random() * 100;
        const top = Math.random() * 100;
        star.style.left = `${left}%`;
        star.style.top = `${top}%`;
        const size = Math.random() * 1 + 0.3;
        star.style.width = `${size}px`;
        star.style.height = `${size}px`;
        document.getElementById('page-wrapper').appendChild(star);
        stars.push({ element: star, left, top, initialLeft: left, initialTop: top });
        animateStar(stars[stars.length - 1]);
      }
    }

    function animateStar(star) {
      const speed = Math.random() * 1 + 0.1;
      const direction = Math.random() * Math.PI * 2;
      const moveX = Math.cos(direction) * speed * 0.02;
      const moveY = Math.sin(direction) * speed * 0.02;
      function moveStar() {
        star.left += moveX * starSpeedMultiplier;
        star.top += moveY * starSpeedMultiplier;
        if (star.left < 0) star.left = 100;
        if (star.left > 100) star.left = 0;
        if (star.top < 0) star.top = 100;
        if (star.top > 100) star.top = 0;
        star.element.style.left = `${star.left}%`;
        star.element.style.top = `${star.top}%`;
        requestAnimationFrame(moveStar);
      }
      moveStar();
    }

    setTimeout(() => {
      createStars(200);
      setTimeout(() => {
        document.querySelectorAll('.star').forEach(star => {
          star.style.opacity = Math.random() * 0.8 + 0.2;
        });
      }, 100);
    }, 1000);

    function applyGlobalWiggleContinuously() {
      const wrapper = document.getElementById('page-wrapper');
      const wiggleStart = 10.0;  
      const wiggleEnd = 35.0; 
      
      if (lastScale < wiggleStart || lastScale >= wiggleEnd) {
        wrapper.style.transform = 'translate(0px, 0px)';
      } else {
        const intensity = Math.min(1, (lastScale - wiggleStart) / 4);
        const maxShake = 5; 
        const offsetX = (Math.random() - 0.5) * maxShake * intensity;
        const offsetY = (Math.random() - 0.5) * maxShake * intensity;
        wrapper.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
      }
      requestAnimationFrame(applyGlobalWiggleContinuously);
    }

    // --- GESTIONE DELLO ZOOM ---
    function processZoom(zoomDelta) {
      if (zoomDelta > 0) scale *= 1 + ((zoomFactor - 1) * dampingFactor);
      else if (zoomDelta < 0) scale /= 1 + ((zoomFactor - 1) * dampingFactor);
      
      scale = Math.max(1, Math.min(maxScale, scale));
      lastScale = scale; 
      
      // Nasconde gradualmente il canvas della rete su smartphone ai primi scroll
      if (window.innerWidth < 600 && scale > 1.5 && !gridHidden) {
        document.getElementById('grid').classList.add('canvas-hidden');
        gridHidden = true;
      }
      
      updateBlackHole(scale);
      updateStarsZoom();
      updateVideoZoom(scale);
      updateSequenceTexts(scale);
    }

    window.addEventListener('wheel', (e) => {
      if (!zoomEnabled) { e.preventDefault(); return; }
      document.getElementById('scroll-hint').style.display = 'none';
      e.preventDefault();
      processZoom(e.deltaY);
    }, { passive: false });

    let touchStartY = 0;
    window.addEventListener('touchstart', (e) => {
      if (!zoomEnabled) return;
      touchStartY = e.touches[0].clientY;
      document.getElementById('scroll-hint').style.display = 'none';
    }, { passive: false });

    window.addEventListener('touchmove', (e) => {
      if (!zoomEnabled) return;
      e.preventDefault(); 
      const touchY = e.touches[0].clientY;
      const deltaY = touchStartY - touchY; 
      touchStartY = touchY; 
      
      processZoom(deltaY * 2); 
    }, { passive: false });
    // ---------------------------

    function updateBlackHole(scale) {
      const bh = document.getElementById('black-hole');
      const aura = document.getElementById('black-hole-aura');
      bh.style.transform = `translate(-50%, -50%) scale(${scale})`;
      aura.style.transform = `translate(-50%, -50%) scale(${scale * 1.3})`;
      bh.style.borderWidth = `${2 / scale}px`;
    }

    function updateStarsZoom() {
      stars.forEach(star => {
        const dx = (star.initialLeft / 100) * width - centerX;
        const dy = (star.initialTop / 100) * height - centerY;
        star.left = ((centerX + dx * (1 + (scale - 1) * 0.2)) / width) * 100;
        star.top = ((centerY + dy * (1 + (scale - 1) * 0.2)) / height) * 100;
        star.element.style.left = `${star.left}%`;
        star.element.style.top = `${star.top}%`;
        
        if (currentPhase >= 5) {
          star.element.style.opacity = '0';
        } else if (scale > videoAppearThreshold * 0.8) {
          star.element.style.opacity = Math.max(0, 0.8 - (scale - videoAppearThreshold * 0.8) / 10);
        } else {
           star.element.style.opacity = Math.random() * 0.8 + 0.2;
        }
      });
    }
    
    function updateVideoZoom(scale) {
      if (scale >= videoAppearThreshold && !videoVisible) {
        videoContainer.style.opacity = '1';
        videoVisible = true;
        
        if(collapseVideos && collapseVideos.length > 0) {
           collapseVideos.forEach(video => {
             video.play().catch(e => console.log("Autoplay protetto dal browser."));
           });
        }
      } else if (scale < videoAppearThreshold && videoVisible) {
        videoContainer.style.opacity = '0';
        videoVisible = false;
      }
      
      if (scale >= videoAppearThreshold) {
        const easeScale = Math.pow(Math.min(1, (scale - videoAppearThreshold) / (videoFullscreenThreshold - videoAppearThreshold)), 1.5);
        videoContainer.style.transform = `translate(-50%, -50%) scale(${0.01 + easeScale * 0.99})`;
        
        if (scale >= slideThreshold) {
          const slidePerc = Math.min(200, Math.max(0, ((scale - slideThreshold) / (slideCompleteThreshold - slideThreshold)) * 200));
          videoSlider.style.left = `${-slidePerc / 3}%`;
        } else {
          videoSlider.style.left = '0%';
        }
      } else {
        videoContainer.style.transform = `translate(-50%, -50%) scale(0.01)`;
      }
    }
    
    function updateSequenceTexts(scale) {
      let detectedPhase = -1;
      const textThresholds = getActiveThresholds();
      
      // Su mobile il buco nero riempie lo schermo prima, quindi inglobiamo il testo prima
      const thresholdForInside = window.innerWidth < 600 ? 9 : 12;

      sequenceTexts.forEach((text, index) => {
        const threshold = textThresholds[index];
        if (scale >= threshold.min && scale <= threshold.max) {
          detectedPhase = index;
          const visibilityWindow = threshold.max - threshold.min;
          const position = scale - threshold.min;
          
          let opacity = position < visibilityWindow * 0.1 ? position / (visibilityWindow * 0.1) : 
                        position > visibilityWindow * 0.9 ? 1 - (position - visibilityWindow * 0.9) / (visibilityWindow * 0.1) : 1;
          
          text.style.opacity = opacity.toString();
          
          const minFontSize = window.innerWidth < 600 ? 14 : 16; 
          const maxFontSize = window.innerWidth < 600 ? 18 : 24; 
          text.style.fontSize = `${minFontSize + (maxFontSize - minFontSize) * (position / visibilityWindow)}px`;

          if (scale > thresholdForInside) {
            text.classList.add('pos-inside');
          } else {
            text.classList.remove('pos-inside');
          }

        } else {
          text.style.opacity = '0';
        }
      });

      if (detectedPhase === -1 && scale < textThresholds[0].min) {
        detectedPhase = 0; 
      }

      if (currentPhase !== detectedPhase) {
        currentPhase = detectedPhase;
        triggerPhaseAnimation(currentPhase);
      }
    }

    function triggerPhaseAnimation(phase) {
      const aura = document.getElementById('black-hole-aura');
      const bh = document.getElementById('black-hole');
      
      starSpeedMultiplier = 1;
      aura.style.background = 'radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 80%)';
      bh.style.borderColor = 'white';
      bh.style.backgroundColor = 'black';
      
      switch(phase) {
        case 0: aura.style.background = 'radial-gradient(circle, rgba(200,200,255,0.4) 0%, transparent 80%)'; break;
        case 1: break;
        case 2: aura.style.background = 'radial-gradient(circle, rgba(255,100,0,0.5) 0%, transparent 80%)'; bh.style.borderColor = '#ffaa00'; starSpeedMultiplier = 4; break;
        case 3: starSpeedMultiplier = 0.02; break;
        case 4: aura.style.background = 'radial-gradient(circle, rgba(0,0,0,0.8) 0%, transparent 80%)'; bh.style.borderColor = 'darkred'; starSpeedMultiplier = 0.5; break;
        case 5: bh.style.borderColor = '#aa00ff'; break;
        case 6: 
          aura.style.background = 'radial-gradient(circle, rgba(50,50,255,0.1) 0%, transparent 80%)';
          bh.style.backgroundColor = 'black'; 
          bh.style.borderColor = 'rgba(255,255,255,0.2)'; 
          break;
        case 7: 
          aura.style.background = 'radial-gradient(circle, rgba(50,50,255,0.2) 0%, transparent 80%)';
          bh.style.backgroundColor = 'black'; 
          bh.style.borderColor = 'rgba(255,255,255,0.0)'; 
          break;
      }
      
      updateStarsZoom();
    }

    let startTime = null;
    function renderLoop(timestamp) {
      if (!startTime) startTime = timestamp;
      const elapsedTime = (timestamp - startTime) / 1000;

      if (animatingLines) {
        drawGrid(0, Math.max(0, elapsedTime - 1));
        if (elapsedTime >= 6) animatingLines = false;
      } else {
        drawGrid((scale - 1) * 2.5, 100); 
      }
      
      if (currentPhase === 5) {
        drawRadialGravityLines(elapsedTime);
      }
      
      requestAnimationFrame(renderLoop);
    }
    
    requestAnimationFrame(renderLoop);

    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });
  </script>
</body>
</html>
